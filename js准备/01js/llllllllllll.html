<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
</body>
<script>
    var obj=[1,1,1,1,1,1];
   var a=Object.prototype.toString.call(111111111111111111).slice(8,-1);
   console.log(a);
   var b=obj.__proto__ === Array.prototype;
    console.log(b);
    var c=Array.isArray(obj);
    console.log(c);
    var d=obj instanceof Array;
    console.log(d);
    var e=Array.prototype.isPrototypeOf(obj)
    console.log(e);
  

    console.log("-------------------");

    6.
    myInstanceof(120,150);
    function myInstanceof(left, right) {
  // 获取对象的原型
  let proto = Object.getPrototypeOf(left)
  // 获取构造函数的 prototype 对象
  let prototype = right.prototype; 
  // 判断构造函数的 prototype 对象是否在对象的原型链上
  while (true) {
    if (!proto) return false;
    if (proto === prototype) return true;
    // 如果没有找到，就继续从其原型上找，Object.getPrototypeOf方法用来获取指定对象的原型
    proto = Object.getPrototypeOf(proto);
  }
}

console.log("------------------");

var f=void 0;
console.log(f);

console.log(1==1);
console.log('1' == { name: 'js' });  

console.log("----------------");
//17.
const h="abc";
console.log(h.length); 
console.log("17:"+h.toUpperCase());//toUpperCase() 大写

var a = 'abc'
console.log(Object(a));//String {'abc'}
var b=Object(a);
//valueOf方法将包装类型倒转成基本类型：
var c=b.valueOf();
console.log(c);//abc

var a = new Boolean( false );if (!a) {
	console.log( "Oops" ); // never runs
}

console.log("-------");
//es6 1.
/* let a3 = {x1: 1, x2: 2, x3: 3}
a3 = {x1: 11, x2:22, x3: 33}
console.log("= = a3 is ", a3);错误 */
let a3 = {x1: 1, x2: 2, x3: 3}
let a2 = a3
a2.x1 = "xxxxx"
console.log("= = a3 is ", a3)


let b1 = 2
let b2 = b1

b2 = 33
console.log("= = b1 is ", b1)

function Person(name, age) {  
 this.name = name;  
 this.age = age;   
}  
var person = new Person("Alice", 23);
console.log(person);


console.log("------------");
function objectFactory() {
  let newObject = null;
  let constructor = Array.prototype.shift.call(arguments);
  let result = null;
  // 判断参数是否是一个函数
  if (typeof constructor !== "function") {
    console.error("type error");
    return;
  }
  // 新建一个空对象，对象的原型为构造函数的 prototype 对象
  newObject = Object.create(constructor.prototype);
  // 将 this 指向新建对象，并执行函数
  result = constructor.apply(newObject, arguments);
  // 判断返回对象
  let flag = result && (typeof result === "object" || typeof result === "function");
  // 判断返回结果
  return flag ? result : newObject;
}// 使用方法
objectFactory("构造函数", "初始化参数");

//js 3.
console.log("----------");
const map = new Map([
     ["foo",1],
     ["bar",2],
])
for(let key of map.keys()){
    console.log(key);  // foo bar
}for(let value of map.values()){
     console.log(value); // 1 2
}for(let items of map.entries()){
    console.log(items);  // ["foo",1]  ["bar",2]
}
map.forEach( (value,key,map) => {
     console.log(key,value); // foo 1    bar 2
})

let get =map.get("foo");
console.log("key对应的键值"+get);
console.log("size="+map.size);
console.log("set(key,value"+map.set("bar",2));

console.log("------------");
//3.map
var m=new Map()
m.set('aa',67);
m.set('aa',66);
m.set('aa',[66,55]);
m.set('bb',[66,55]);
m.set('cc',[66,55]);
console.log(m.has('aa'));
console.log(m.get('aa'));
m.delete("aa");
console.log(m.get('aa'));
console.log(m.keys());

var m = new Map();
var s1 = [1,2]
var s2 = {"a": 11, "b": 22}
m.set(s1, 101);
m.set(s2, 102);
console.log(m.get(s1));
console.log(m.get(s2));
console.log(s1);
console.log(m.keys());

let g = new Map();
g.set("aa", 1)
g.set("bb", 2)
g.set("cc", 3)
g.set("dd", 4)
for (let k of g.keys()) {
  console.log(k + " and value: " + g.get(k))
}
console.log("-----------------");

let i = new Map();
i.set("aa", 1)
i.set("bb", 2)
i.set("cc", 3)
i.set("dd", 4)
for (let k of i.keys()) {
  console.log(k + " and value: " + i.get(k))
}

i.forEach((v, k) => {
  console.log(k + " and value0: " + i.get(k))
})

i.forEach( function(v) {
  console.log( " and value1: " + i.get(v))
})


console.log("-----------");
let m1 = new Map();
m1.set("aa", 1)
m1.set("bb", 2)
m1.set("cc", 3)
m1.set("dd", 4)

for (let k of m1.keys()) {
  console.log(k + " and value: " + m1.get(k))
}

m1.forEach((value, key) => {
  console.log(key + " and value0: " + value)
  console.log("ztr")
})

m1.forEach(function(v, k, m) {
  console.log(k + " and value1: " + v)
})



console.log("----------");


const key1 = {id: 1},
      key2 = {id: 2},
      key3 = {id: 3};
// 使用嵌套数组初始化弱映射
const wm1 = new WeakMap([
  [key1, "val1"],
  [key2, "val2"],
  [key3, "val3"]
]);
console.log(wm1.get(key1)); // val1
console.log(wm1.get(key2)); // val2
console.log(wm1.get(key3)); 


// 初始化是全有或全无的操作
// 只要有一个键无效就会抛出错误，导致整个初始化失败
/* const wm2 = new WeakMap([
  [key1, "val1"],
  ["BADKEY", "val2"],
  [key3, "val3"]
]);
// TypeError: Invalid value used as WeakMap key
typeof wm2;
// ReferenceError: wm2 is not defined
// 原始值可以先包装成对象再用作键
const stringKey = new String("key1");
const wm3 = new WeakMap([
  stringKey, "val1"
]);
alert(wm3.get(stringKey)); // "val1" */

var packJson = [{"name":"Liza", "password":"123"}, {"name":"Mike", "password":"456"}];
for(var q in packJson){//遍历packJson 数组时，i为索引
console.log(packJson[q].name + " " + packJson[q].password);
}


console.log("----------");
let weakmap1=new WeakMap();
function qq_1(){
  let s='{"a": 2}'
  let value=JSON.parse(s)
  console.log(typeof(s))
  console.log(typeof(value))
}
qq_1();


console.log("-----数组原生方法（首部操作）-----");
var arr=[1,2,3,5,8,99];
arr.shift(222);//删除第一个元素
console.log(arr);
var arr=[1,2,3,5,8,99];

arr.unshift(11111111,4444);//在首部添加值
console.log(arr);

var hege = ["Cecilie", "Lone"];
var stale = ["Emil", "Tobias", "Linus"];
var kai = ["Robin"];
var children = hege.concat(stale,kai);
console.log(children);

</script>
</html>